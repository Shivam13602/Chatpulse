AWSTemplateFormatVersion: '2010-09-09'
Description: 'Real-Time Chat Application with Sentiment Analysis - Main Infrastructure'

Resources:
  # IAM Roles
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
        - 'arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess'
        - 'arn:aws:iam::aws:policy/AmazonS3FullAccess'

  EC2S3AccessRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonS3FullAccess'

  APIGatewayLambdaInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: LambdaInvokePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 'lambda:InvokeFunction'
                Resource: '*'

  # S3 Bucket
  ChatStorageBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'real-time-chat-storage-${AWS::AccountId}'
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  # DynamoDB Tables
  ConnectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: ConnectionsTable
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: connectionId
          AttributeType: S
      KeySchema:
        - AttributeName: connectionId
          KeyType: HASH

  MessagesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: MessagesTable
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: messageId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
      KeySchema:
        - AttributeName: messageId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: TimestampIndex
          KeySchema:
            - AttributeName: timestamp
              KeyType: HASH
          Projection:
            ProjectionType: ALL

  # EC2 Instance for Model Training
  ModelTrainingInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t3.micro
      ImageId: ami-0889a44b331db0194  # Amazon Linux 2023 AMI (update with correct AMI for your region)
      IamInstanceProfile: !Ref EC2InstanceProfile
      SecurityGroups:
        - !Ref ModelTrainingSecurityGroup
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          yum update -y
          yum install -y git python3
          pip3 install boto3
          mkdir -p /home/ec2-user/model-training
          cat > /home/ec2-user/model-training/retrain_model.py << 'EOF'
          import boto3
          import datetime

          def retrain():
              # Placeholder for model retraining logic
              print("Retraining model...")

          if __name__ == "__main__":
              retrain()
              # Upload the updated model to S3
              s3 = boto3.client('s3')
              s3.upload_file('/home/ec2-user/model-training/sentiment_model.pkl', 'real-time-chat-storage-${AWS::AccountId}', 'models/sentiment_model.pkl')
          EOF
          chmod +x /home/ec2-user/model-training/retrain_model.py
          echo "0 0 * * * /home/ec2-user/model-training/retrain_model.py >> /home/ec2-user/model-training/retrain.log 2>&1" | crontab -

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2S3AccessRole

  ModelTrainingSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for model training EC2 instance
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0  # Restrict to your IP in a real environment

  # Lambda Functions
  ConnectionManagerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: ConnectionManager
      Runtime: python3.12
      Handler: connection_manager.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import time
          import os
          import logging

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Initialize DynamoDB client
          dynamodb = boto3.resource('dynamodb')
          connections_table = dynamodb.Table(os.environ.get('CONNECTIONS_TABLE_NAME', 'ConnectionsTable'))

          def lambda_handler(event, context):
              try:
                  connection_id = event['requestContext']['connectionId']
                  event_type = event['requestContext']['eventType']
                  
                  logger.info(f"Received {event_type} event for connection ID: {connection_id}")
                  
                  if event_type == 'CONNECT':
                      # Store the connection in DynamoDB
                      response = connections_table.put_item(
                          Item={
                              'connectionId': connection_id,
                              'connectedAt': int(time.time()),
                              'status': 'CONNECTED'
                          }
                      )
                      logger.info(f"Successfully stored connection {connection_id}")
                      
                  elif event_type == 'DISCONNECT':
                      # Remove the connection from DynamoDB
                      response = connections_table.delete_item(
                          Key={
                              'connectionId': connection_id
                          }
                      )
                      logger.info(f"Successfully removed connection {connection_id}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': f"Successful {event_type}"})
                  }
                  
              except Exception as e:
                  logger.error(f"Error processing {event.get('requestContext', {}).get('eventType', 'unknown')} event: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'message': f"Error: {str(e)}"})
                  }
      Environment:
        Variables:
          CONNECTIONS_TABLE_NAME: !Ref ConnectionsTable
      Timeout: 30
      MemorySize: 128

  MessageProcessorFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - ConnectionsTable
      - MessagesTable
    Properties:
      FunctionName: MessageProcessor
      Runtime: nodejs20.x
      Handler: message_processor.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          const AWS = require('aws-sdk');

          // Initialize AWS services
          const dynamoDB = new AWS.DynamoDB.DocumentClient();
          let apiGateway;

          // Define positive and negative word lists for basic sentiment analysis
          const POSITIVE = ['happy', 'great', 'excellent', 'good', 'love', 'awesome', 'fantastic', 'wonderful', 'nice', 'amazing'];
          const NEGATIVE = ['sad', 'bad', 'awful', 'terrible', 'horrible', 'hate', 'dislike', 'angry', 'upset', 'disappointed'];

          // Generate a simple unique ID (in production, use a proper UUID library)
          function generateUniqueId() {
            return 'xxxxxxx'.replace(/[x]/g, () => Math.floor(Math.random() * 16).toString(16));
          }

          exports.handler = async (event) => {
              console.log('Event received:', JSON.stringify(event));
              
              // Initialize API Gateway with the correct endpoint from the event
              const domain = event.requestContext.domainName;
              const stage = event.requestContext.stage;
              apiGateway = new AWS.ApiGatewayManagementApi({
                  endpoint: `${domain}/${stage}`
              });
              
              try {
                  // Extract connection ID and message data
                  const connectionId = event.requestContext.connectionId;
                  const body = JSON.parse(event.body);
                  
                  // Ensure body has expected format
                  if (!body.action || !body.data) {
                      return { statusCode: 400, body: JSON.stringify({ message: 'Invalid message format' }) };
                  }

                  // Only process 'sendmessage' action
                  if (body.action !== 'sendmessage') {
                      return { statusCode: 200, body: JSON.stringify({ message: 'Unsupported action' }) };
                  }

                  const text = body.data;
                  
                  // Perform simple sentiment analysis
                  let score = 0;
                  const words = text.toLowerCase().split(/\s+/);
                  
                  words.forEach(word => {
                      if (POSITIVE.includes(word)) score += 1;
                      if (NEGATIVE.includes(word)) score -= 1;
                  });
                  
                  // Create message object
                  const message = {
                      messageId: generateUniqueId(),
                      connectionId: connectionId,
                      content: text,
                      sentiment: score,
                      timestamp: Date.now(),
                      userId: body.userId || connectionId // Use provided userId or connectionId as fallback
                  };
                  
                  // Store message in DynamoDB
                  await dynamoDB.put({
                      TableName: process.env.MESSAGES_TABLE_NAME || 'MessagesTable',
                      Item: message
                  }).promise();
                  
                  console.log('Message stored in DynamoDB:', message.messageId);
                  
                  // Fetch all active connections
                  const connectionsData = await dynamoDB.scan({
                      TableName: process.env.CONNECTIONS_TABLE_NAME || 'ConnectionsTable'
                  }).promise();
                  
                  // Broadcast message to all connections
                  const postCalls = connectionsData.Items.map(async ({ connectionId }) => {
                      try {
                          await apiGateway.postToConnection({
                              ConnectionId: connectionId,
                              Data: JSON.stringify({
                                  type: 'message',
                                  data: message
                              })
                          }).promise();
                          console.log(`Message successfully sent to ${connectionId}`);
                      } catch (err) {
                          // Handle stale connections
                          if (err.statusCode === 410) {
                              console.log(`Connection ${connectionId} is stale, removing...`);
                              await dynamoDB.delete({
                                  TableName: process.env.CONNECTIONS_TABLE_NAME || 'ConnectionsTable',
                                  Key: { connectionId }
                              }).promise();
                          } else {
                              console.error(`Error sending message to ${connectionId}:`, err);
                              throw err;
                          }
                      }
                  });
                  
                  // Wait for all broadcast operations to complete
                  await Promise.all(postCalls);
                  
                  return { 
                      statusCode: 200, 
                      body: JSON.stringify({ 
                          message: 'Message processed and broadcast successfully',
                          messageId: message.messageId
                      }) 
                  };
                  
              } catch (err) {
                  console.error('Error processing message:', err);
                  return { 
                      statusCode: 500, 
                      body: JSON.stringify({ 
                          message: 'Error processing message',
                          error: err.message
                      }) 
                  };
              }
          };
      Environment:
        Variables:
          CONNECTIONS_TABLE_NAME: !Ref ConnectionsTable
          MESSAGES_TABLE_NAME: !Ref MessagesTable
      Timeout: 30
      MemorySize: 256

  # WebSocket API and Routes
  WebSocketAPI:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: RealTimeChatWebSocketAPI
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.action"

  # Connect Route
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketAPI
      RouteKey: "$connect"
      AuthorizationType: NONE
      OperationName: ConnectRoute
      Target: !Join
        - /
        - - integrations
          - !Ref ConnectIntegration

  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketAPI
      Description: Connect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectionManagerFunction.Arn}/invocations

  # Disconnect Route
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketAPI
      RouteKey: "$disconnect"
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Join
        - /
        - - integrations
          - !Ref DisconnectIntegration

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketAPI
      Description: Disconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectionManagerFunction.Arn}/invocations

  # Send Message Route
  SendMessageRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketAPI
      RouteKey: "sendmessage"
      AuthorizationType: NONE
      OperationName: SendMessageRoute
      Target: !Join
        - /
        - - integrations
          - !Ref SendMessageIntegration

  SendMessageIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketAPI
      Description: Send Message Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MessageProcessorFunction.Arn}/invocations

  # Stage
  WebSocketAPIStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketAPI
      StageName: prod
      Description: Production Stage
      AutoDeploy: true

  # Lambda Permissions
  ConnectionManagerPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - WebSocketAPI
      - ConnectionManagerFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ConnectionManagerFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketAPI}/*

  MessageProcessorPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - WebSocketAPI
      - MessageProcessorFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref MessageProcessorFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketAPI}/*

Outputs:
  EC2InstanceId:
    Description: ID of the model training EC2 instance
    Value: !Ref ModelTrainingInstance

  S3BucketName:
    Description: Name of the S3 bucket for chat storage
    Value: !Ref ChatStorageBucket

  WebSocketAPIId:
    Description: ID of the WebSocket API
    Value: !Ref WebSocketAPI

  WebSocketURL:
    Description: URL of the WebSocket API
    Value: !Sub 'wss://${WebSocketAPI}.execute-api.${AWS::Region}.amazonaws.com/prod' 